
void
fieldhash(HV* hash)
PROTOTYPE: \%
PREINIT:
	MAGIC* tied_mg;
CODE:
	tied_mg = SvTIED_mg((SV*)hash, PERL_MAGIC_tied);
	if(!tied_mg || !sv_derived_from(SvTIED_obj((SV*)hash, tied_mg), PACKAGE)){
		SV* const self = newRV_noinc((SV*)newHV());
		hv_clear(hash);

		sv_bless(self, gv_stashpvs(PACKAGE, GV_ADD));

		if(tied_mg) sv_unmagic((SV*)hash, PERL_MAGIC_tied);
		sv_magic((SV*)hash, self, PERL_MAGIC_tied, NULL, 0);
		SvREFCNT_dec(self); /* refcnt++ in sv_magic() */

		sv_magicext(SvRV((SV*)self), NULL, PERL_MAGIC_ext, &fieldhash_vtbl, NULL, 0);
	}

SV*
STORE(HV* self, SV* key, SV* val = &PL_sv_undef)
ALIAS:
	FETCH  = 0
	STORE  = HV_FETCH_ISSTORE
	EXISTS = HV_FETCH_ISEXISTS
	DELETE = HV_DELETE
PREINIT:
	MAGIC* mg;
	HE* he;
INIT:
	RETVAL = NULL;
CODE:
	mg = fieldhash_mg((SV*)self);
	if(!mg){
		Perl_croak(aTHX_ "Invalid fieldhash");
	}
	mg->mg_obj = key;
	fieldhash_watch(aTHX_ ix /* as action */, (SV*)self);
	key = mg->mg_obj;
	mg->mg_obj = NULL;

	assert(key);

	switch(ix){
	default: /* FETCH */
		he = hv_fetch_ent(self, key, 0, 0U);
		if(he){
			RETVAL = hv_iterval(self, he);
		}
		break;

	case HV_FETCH_ISSTORE:
		hv_store_ent(self, key, newSVsv(val), 0U);
		RETVAL = val;
		break;

	case HV_FETCH_ISEXISTS:
		RETVAL = boolSV(hv_exists_ent(self, key, 0U));
		break;

	case HV_DELETE:
		RETVAL = hv_delete_ent(self, key, 0, 0U);
		break;
	}

	ST(0) = RETVAL ? RETVAL : &PL_sv_undef;
	XSRETURN(1);


void
FIRSTKEY(HV* self, SV* last_key = &PL_sv_undef)
ALIAS:
	FIRSTKEY = 0
	NEXTKEY  = 1
PREINIT:
	HE* he;
CODE:
	if(ix == 0){ /* FIRSTKEY */
		hv_iterinit(self);
	}
	he = hv_iternext(self);
	ST(0) = he ? hv_iterkeysv(he) : &PL_sv_undef;
	XSRETURN(1);


void
CLEAR(HV* self)
CODE:
	hv_clear(self);

